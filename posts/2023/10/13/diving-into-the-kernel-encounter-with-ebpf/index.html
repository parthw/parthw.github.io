<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Diving into the Kernel: Encounter with eBPF | parthw</title>
<link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css rel=stylesheet>
<link rel=stylesheet href=/css/style.css>
</head>
<body>
<nav>
<ul>
<li><a href=/>About</a></li>
<li><a href=/posts/>Posts</a></li>
<li><a href=/index.xml>Subscribe</a></li>
</ul>
</nav>
<div class=title>Diving into the Kernel: Encounter with eBPF</div>
<p>Hello there! I recently became fascinated by the world of monitoring, which eventually led me to discover eBPF.
As I started digging into eBPF, I found it super cool and got hooked. It made me want to explore the inner workings of the kernel.
With this newfound enthusiasm, I&rsquo;m excited to announce the launch of my own blog series where I&rsquo;ll share my experiences and insights about eBPF and kernel as I learn along the way.</p>
<h2 id=the-linux-kernel>The Linux Kernel</h2>
<p>To understand eBPF, you will need to understand what is kernel, what is user space and what is system call.</p>
<p>The Linux kernel is the software layer that acts as an intermediary between applications and the underlying hardware on which they operate. Our applications run in an unprivileged layer known as &lsquo;user space&rsquo;, and they lack direct access to hardware. Instead, applications communicate with the hardware through a system call interface, where they request the kernel to facilitate interactions with the hardware on their behalf. The kernel is responsible for handling scheduling, concurreny of processes, memory management etc. This is better illustrated in <a href=https://www.nutanixbible.com/0-a-brief-lesson-in-history.html>nutanixbibile.com</a> as -</p>
<p><img src=user_kernel.png alt=user_kernel></p>
<h2 id=what-is-ebpf>What is eBPF?</h2>
<p>Extended Berkeley Packet Filter (eBPF) is a Linux kernel feature that makes it possible to run sandboxed programs inside the kernel space in a safe and controlled manner, allowing us to modify and extend the kernel without having to alter and re-compiling the kernel’s source code. <code>Don't judge it by name, it is not just a packet filter anymore.</code></p>
<p>It was introduced in the Linux kernel version 3.15 in 2014. It was originally developed as an extension of the Berkeley Packet Filter (BPF) to allow for more complex and dynamic filtering of network packets. Since then, eBPF has evolved to become a powerful and flexible tool for tracing, profiling, security analysis etc.</p>
<blockquote>
<p>In Brendan Gregg’s own words: &ldquo;eBPF does to Linux what JavaScript does to HTML.&rdquo;</p>
</blockquote>
<p>One of eBPF&rsquo;s most notable aspects is the <code>eBPF verifier</code>, a component that enhances the safety of kernel execution. Allow me to clarify what <code>safer</code> means in this context.</p>
<p>In the past, if you needed a specific feature in the kernel, the process involved making a request within the kernel community. Even if you embarked on the development journey, there was no guarantee that your changes would be accepted. Moreover, releasing these kernel modifications and having them integrated into the OS your organization uses is a time-consuming process which can take few months to years.</p>
<p>An alternative approach was to utilize kernel modules, which could be loaded or unloaded on demand. These modules offered a way to tweak the behavior of the kernel. However, writing a kernel module required utmost caution because any mistakes or crashes in the module could lead to a kernel panic, taking down the entire system.</p>
<p>Without further ado, let us set up our development environment and learn by doing, as it is more exciting.</p>
<h2 id=development-environment>Development environment</h2>
<p>I&rsquo;m currently doing development using Ubuntu 22.04.3 in virtual machine with kernel version 6.2.
I&rsquo;ve chosen to use a virtual machine as a safety measure to avoid the risk of potentially damaging my primary system.</p>
<p>To get started, the first step is to run the following commands to install the necessary packages:</p>
<pre><code class=language-bash>sudo apt install -y linux-headers-$(uname -r) libbpfcc-dev libbpf-dev llvm clang libclang-dev gcc-multilib build-essential linux-tools-$(uname -r) linux-tools-common linux-tools-generic vim python-is-python3 elfutils dwarves git flex bison libssl-dev libelf-dev cmake libedit-dev zip libfl-dev python3-setuptools liblzma-dev libdebuginfod-dev arping netperf iperf


sudo apt-get -y install luajit luajit-5.1-dev
</code></pre>
<p>These commands will set up LLVM, Clang, and other packages on your system. We will be discussing most of them in upcoming blog posts when we use them. The important thing to note is that these commands will set up LLVM version 14 if you are using Ubuntu 22.04.3. LLVM version can vary according to the Ubuntu version in use.</p>
<p>We&rsquo;ll also be writing the code in golang so, to install the latest version of golang, run the following commands:</p>
<pre><code class=language-bash>sudo add-apt-repository ppa:longsleep/golang-backports
sudo apt update
sudo apt install golang-go
</code></pre>
<p>In start, we will also use the most accessible approch to write eBPF programs that is via the BCC Python Framework.
Next we will be setting up, bcc framework and run an example to verify whether the setup is done correctly or not.
The official instructions are mentioned on <a href=https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---source>BCC install.md</a>.</p>
<blockquote>
<p>Note: If you are using Ubuntu 20.04, you will need to upgrade LLVM to version 11 or above to compile iovisor BCC; or you can use the environment variable LLVM_ROOT to select the alternative LLVM version. In this series, we will be going ahead with llvm version 14.</p>
</blockquote>
<p>With the above packages, to install and compile BCC framework, run the following commands:</p>
<pre><code class=language-bash>git clone https://github.com/iovisor/bcc.git
mkdir bcc/build; cd bcc/build
cmake ..
make
sudo make install
cmake -DPYTHON_CMD=python3 .. # build python3 binding
pushd src/python/
make
sudo make install
popd
</code></pre>
<h2 id=verify-the-setup>Verify the setup</h2>
<p>To verify that iovisor BCC is installed and configured correctly, run the following command:</p>
<pre><code class=language-bash>cd /usr/share/bcc/examples
./hello_world.py
</code></pre>
<p>If you see the output as <code>Hello, World!</code>, then the setup is correct.</p>
<p>I remember the first time I ran this command. It was like entering a mysterious territory full of new possibilities. Seeing the &ldquo;Hello, World!&rdquo; output gave me the confidence to dig deeper. And I&rsquo;m hooked.</p>
<h2 id=upcoming-post>Upcoming post</h2>
<p>In my next post, I&rsquo;ll walk you through the steps of creating your first &ldquo;Hello, World!&rdquo; eBPF program, line by line. I&rsquo;ll also introduce some of the more exciting eBPF constructs, such as probes, and how to use them to write useful eBPF programs.</p>
<p>Thanks for reading and stay tuned!</p>
<footer>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script>
<hr>
<div>
© <a href=https://www.linkedin.com/in/parth-wadhwa/>Parth Wadhwa</a> 2023 | <a href=https://github.com/parthw>Github</a> | <a href=https://twitter.com/_parthwadhwa>Twitter</a>
</div>
</footer>
</body>
</html>